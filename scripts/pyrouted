#!/usr/bin/python

import os
import sys
import json
import traceback
import pyrouted
from socket import AF_INET
from socket import AF_UNIX
from socket import SOCK_STREAM
from socket import fromfd
from socket import socket

##
# load url from the command line
#
if (sys.argv) == 1:
    # no command line arguments provided
    # FIXME: either implement auth, either move it
    # to the real filesystem with access rights,
    # but the best -- do both
    url = '\x00pyrouted'
    family = AF_UNIX
else:
    # url provided
    # possible variants:
    # 1. pyrouted 8080
    #    -- run pyrouted on 0.0.0.0:8080
    # 2. pyrouted @pyrouted
    #    -- run on AF_UNIX, abstract socket NS
    # 3. pyrouted /tmp/my_socket
    #    -- AF_UNIX, absolute path
    # 4. pyrouted my_socket
    #    -- AF_UNIX, relative path

    # FIXME: handle ValueError exception in loads
    url = json.loads('"%s"' % sys.argv[1])
    try:
        # try to decode url as port -- must be int
        url = ('', int(url))
        # ok, it is AF_INET
        family = AF_INET
    except ValueError:
        # fallback to AF_UNIX
        if url[0] == '@':
            # handle abstract socket namespace path
            url = '\x00%s' % url[1:]
        family = AF_UNIX
##
# create the socket
#
if os.environ.get('LISTEN_PID', None) == str(os.getpid()):
    # FIXME: don't use hardcoded FD == 3
    s = fromfd(3, family, SOCK_STREAM)
else:
    s = socket(family, SOCK_STREAM, 0)
    s.bind(url)
    s.listen(16)
(c, addr) = s.accept()

##
# load commands namespace
#
commands = pyrouted.Commands()

##
# handle the call
#
try:
    transport = pyrouted.Transport(sock=c)
    call = transport.get()
    transport.put(commands(call))
except:
    traceback.print_exc()
finally:
    transport.release()
    c.close()
    commands.ipdb.release()
    if os.environ.get('LISTEN_PID', None) != str(os.getpid()):
        s.close()
